1) Definition of JavaScript:
    JavaScript (JS) is a high-level, interpreted, dynamic, and object-oriented programming language mainly used to make web pages interactive.

👉 In short:

HTML = structure (what’s on the page)

CSS = style (how it looks)

JavaScript = behavior (how it works / interacts with users)

Example:

HTML makes a button.

CSS makes it look nice.

JavaScript makes it do something when clicked.

2) Introduction to JavaScript:
    JavaScript was created in 1995 by Brendan Eich while working at Netscape.
    Originally called Mocha → LiveScript → JavaScript (to ride on Java’s popularity at that time).
    It’s now standardized under ECMAScript (ES) specifications.

✅ Today, JS is everywhere:

Web browsers (frontend: dynamic content, animations, form validation)

Servers (backend with Node.js)

Mobile apps (React Native, Ionic)

Desktop apps (Electron)

Game development & IoT


👉 Key Features of JavaScript

Lightweight & Easy to Learn – simple syntax, beginner-friendly.

Interpreted Language – runs directly in browsers (no need to compile).

Dynamic Typing – variables don’t need fixed data types (let x = 10; x = "hello";).

Prototype-based OOP – objects are built from other objects (prototypes).

Event-driven & Asynchronous – handles user actions (clicks, input) and async tasks (fetching data).

Cross-platform – works on Windows, Linux, Mac, browsers, and servers.


👉 Why is JavaScript Important?

    Without JavaScript: websites would be static (just text and images).
    With JavaScript: websites become dynamic & interactive.

👉 Examples of what JS can do:

Show popups and alerts.

Validate forms before submission.

Create image sliders, animations, and menus.

Fetch live data from servers (AJAX, APIs).

Build full apps (like Gmail, Facebook, YouTube frontend).

👉 First Example:

<!DOCTYPE html>
<html>
<head>
  <title>JS Example</title>
</head>
<body>
  <h1>Hello JavaScript</h1>
  <button onclick="greet()">Click Me</button>

  <script>
    function greet() {
      alert("Welcome to JavaScript!");
    }
  </script>
</body>
</html>


👉 Here:

HTML creates the button.

JavaScript adds behavior (alert on click).

3) JavaScript Comments:

👉 Comments are notes written inside your code that are ignored by JavaScript engines.

They don’t affect how the program runs.

They are used to explain code, make it readable, and help in debugging.

Think of comments as notes for humans, not computers.

👉 Types of Comments in JavaScript:

JavaScript supports two types of comments:

1. Single-line Comment (//)

Starts with //.

Anything after // on that line is treated as a comment.

Useful for short notes or disabling one line of code.

Example:

// This is a single-line comment
let name = "Rahul"; // This sets the name variable
    
    
2. Multi-line Comment (/* ... */)

Starts with /* and ends with */.

Can span multiple lines.

Useful for long explanations or commenting out blocks of code.

Example:

/* This is a multi-line comment
It can span multiple lines
Good for detailed notes */
let age = 21;


4) Javascript Variables:

A variable is a named container used to store data in JavaScript.

You can think of it like a box with a label (name of the variable).

The box stores data (numbers, text, objects, etc.).

Later, you can use or change the data stored inside.

👉 Example:

let name = "Rahul";   // storing text (string)
let age = 21;         // storing number
let isStudent = true; // storing boolean

👉 Why Do We Need Variables?

To store values temporarily in memory.

To reuse values multiple times without rewriting them.

To manipulate data dynamically (e.g., score in a game, balance in ATM program).

👉 Rules Of Declare A Variable In JS:

Name Must Start With a letter (a to z , A to Z), Underscore(_),or Dollar ($) sign.

Variable Can not start with a number. After First letter we can use number.
eg: value1.

JavaScript Variables are Case Sensitive.

JavaScript variables can not use reserved keyword.
eg: if, function, class.

JavaScript Variables can not allow spaces (whitespace).

Best Practice: Use camelCase (myName, totalAmount).


👉 Declaring Variables in JavaScript

There are three keywords to declare variables:

1. var (Old way, before ES6)

Function-scoped (available inside a function, not blocks { }).

Can be redeclared (which may cause bugs).

Hoisted (moved to top in memory but set as undefined).

Example:

var city = "Pune";
var city = "Mumbai";   // ✅ Allowed (redeclared)
console.log(city);     // Mumbai


2. let (Modern way, ES6)

Block-scoped (only works inside { }).

Cannot be redeclared in the same block.

Can be reassigned.

Hoisted but exists in a Temporal Dead Zone (TDZ) until initialized (so you get an error if you use it before declaration).

Example:

let age = 20;
// let age = 21; ❌ Error (cannot redeclare)
age = 21;              // ✅ Allowed (reassign)
console.log(age);      // 21


3. const (Constant values)

Block-scoped like let.

Must be initialized when declared.

Cannot be redeclared or reassigned.

But ❗ if you store an object/array, you can still modify its contents (the reference is constant, not the data).

Example:

const PI = 3.1416;
// PI = 3.15; ❌ Error (cannot reassign)

const student = { name: "Rahul" };
student.name = "Kamat"; // ✅ Allowed (changing property)
console.log(student.name); // Kamat


👉 Difference between var, let, and const (Paragraph Explanation):

In JavaScript, variables can be declared using var, let, or const.

1. var is the oldest way (before ES6, 2015). It is function-scoped, meaning it is only limited to the function in which it is declared, 
not blocks like if or for. It can be redeclared and reassigned, but it can cause unexpected behavior due to hoisting 
(it gets moved to the top of its scope and initialized with undefined).

2. let was introduced in ES6 to fix these problems. It is block-scoped, meaning it exists only inside { } where it’s defined. 
It cannot be redeclared in the same scope, but it can be reassigned. Unlike var, it is hoisted but stays in the Temporal 
Dead Zone (TDZ) until initialized.

3. const is also block-scoped like let, but the difference is that it must be initialized at the time of declaration and 
cannot be reassigned later. However, if a const holds an object or array, its contents can still be modified — only the reference cannot change.


👉 Difference between var, let, and const (Table Format):

| Feature              | `var` (Old)                    | `let` (ES6)                       | `const` (ES6)                     |
| -------------------- | ------------------------------ | --------------------------------- | --------------------------------- |
| **Scope**            | Function-scoped                | Block-scoped                      | Block-scoped                      |
| **Redeclaration**    | ✅ Allowed                      | ❌ Not allowed                     | ❌ Not allowed                     |
| **Reassignment**     | ✅ Allowed                      | ✅ Allowed                         | ❌ Not allowed                     |
| **Must Initialize?** | ❌ No                           | ❌ No                              | ✅ Yes                             |
| **Hoisting**         | ✅ Hoisted (set to `undefined`) | ✅ Hoisted (TDZ until initialized) | ✅ Hoisted (TDZ until initialized) |
| **Use Case**         | Legacy code (avoid)            | Variables that change values      | Constants, fixed references       |


👉 Scope Of Variable:

What is Scope?

Scope in JavaScript determines where a variable is accessible in your code.
It answers the question:
➡️ “From which part of the program can I use this variable?”

Types of Scope in JavaScript:

1. Global Scope 🌍

A variable declared outside any function or block { } is global.

Global variables are accessible everywhere in the program.

They live as long as the program runs.

Example:

let globalVar = "I am global"; // Global scope

function test() {
  console.log(globalVar); // ✅ Accessible here
}

test();
console.log(globalVar); // ✅ Accessible here too


⚠️ Problem: Too many global variables may cause naming conflicts and memory leaks.


2. Function Scope (Local Scope) 🔧

Variables declared inside a function are local to that function.

They cannot be accessed outside.

Applies to var, let, and const when declared inside a function.

Example:

function myFunc() {
  let localVar = "I am local";
  console.log(localVar); // ✅ Works
}

myFunc();
console.log(localVar); // ❌ Error (not defined outside)


3. Block Scope 🧱 (introduced in ES6)

Applies to variables declared with let and const inside { }.

They are only available inside that block.

var ❌ does NOT support block scope (it ignores { }).

Example:

if (true) {
  var x = 10;  // Function scoped
  let y = 20;  // Block scoped
  const z = 30; // Block scoped
  console.log(x, y, z); // ✅ 10 20 30
}

console.log(x); // ✅ 10 (var leaks out of block)
console.log(y); // ❌ Error
console.log(z); // ❌ Error

✅ In Summary:

Global Scope → accessible everywhere.

Function Scope → accessible inside a function.

Block Scope → accessible only inside { } (for let and const).


5) DataTypes in JavaScript:

A data type defines the type of data a variable can hold and how it will be stored and manipulated in memory.

Javascript provides diffrent data types to hold diffrent types of values. 

In JavaScript, data types are mainly of two categories:

1. Primitive Data Types (Immutable, stored by value)

2. Non-Primitive (Reference) Data Types (Mutable, stored by reference   )


1. Primitive Data Types

Primitive types are the most basic data types. They are:

Stored directly by value (not by reference).

Immutable → Once created, they cannot be changed (any modification creates a new value).

There are 7 primitive types in JavaScript:

✅ List of Primitive Data Types

👉 String → Represents text.

let name = "Rahul"; // double quotes
let city = 'Mumbai'; // single quotes
let greet = `Hello ${name}`; // template literals


👉 Number → Represents integers, floats, special numbers (NaN, Infinity).

let age = 22;
let pi = 3.14;
let invalid = NaN;
let inf = Infinity;


👉 BigInt → Used for very large integers beyond Number limit.

let bigNum = 123456789012345678901234567890n;


👉 Boolean → Represents logical values: true or false.

let isActive = true;
let isCompleted = false;


👉 Undefined → Default value of a declared but unassigned variable.

let x;
console.log(x); // undefined


👉 Null → Represents intentional empty value (nothing).

let data = null;


👉 Symbol → Unique and immutable, mostly used as object property keys.

const id1 = Symbol("id");
const id2 = Symbol("id");
console.log(id1 === id2); // false (always unique)


2. Non-Primitive (Reference) Data Types

Non-primitive types are complex and:

Stored by reference (the variable holds a memory address, not the actual value).

Mutable → Values can be modified.

Examples include objects, arrays, and functions.

✅ Common Non-Primitive Data Types:

👉 Object: Collection of key-value pairs.

let person = {
  name: "Rahul",
  age: 22
};


👉 Array: Ordered collection (list) of values.

let numbers = [1, 2, 3, 4, 5];


👉 Function: A block of reusable code (in JS, functions are objects).

function greet() {
  return "Hello!";
}


👉 Date, RegExp, Map, Set, WeakMap, WeakSet, etc. : Built-in objects for special purposes.


6) Operators in JavaScript:

Operators are symbols or keywords that perform operations on values (operands). 
In JavaScript they cover arithmetic, assignment, comparison, logical, bitwise, property access, and more.

Overview — Categories of operators

👉 Arithmetic (+ - * / % ** ++ --)

👉 Assignment (=, +=, -= … including logical-assignment &&=, ||=, ??=)

👉 Comparison (< > <= >=, in, instanceof)

👉 Equality (==, ===, !=, !==, Object.is)

👉 Logical (&&, ||, !, ?? (nullish coalescing))

👉 Bitwise (& | ^ ~ << >> >>>)

👉 Unary (typeof, void, delete, unary + - ! ~)

👉 Ternary (condition ? expr1 : expr2)

👉 Misc / Other: comma operator ,, optional chaining ?., spread/rest ..., member access ., computed access [],
    function call (), new, and await (operator-like)


7) Control Flow In JavaScript:

i)Conditional Statement:

A conditional statement in JavaScript is used to make decisions in code.
It checks whether a condition (expression) is true or false and then executes specific blocks of code accordingly.

In simple words:
➡️ Conditional statements control the flow of a program by checking conditions.
➡️ If the condition is true → one block of code runs.
➡️ If the condition is false → another block of code (or nothing) runs.
➡️ Conditional statements allow your program to take different actions based on different conditions.


👉 Why Do We Use Conditional Statements?

To control the flow of the program.

To execute code only when certain conditions are met.

To make the program dynamic and interactive.

👉 Example (real-world logic):

If a user is logged in → show their profile.

Else → show login page.

🔹 Types of Conditional Statements in JavaScript:

JavaScript provides several types of conditional statements:

1. if statement

2. if...else statement

3. if...else if...else statement

4. switch statement

5. Conditional (Ternary) operator 


1️⃣ if Statement

👉 The simplest form of condition.
It executes a block of code only if the condition is true.

Syntax:
if (condition) {
    // Code to execute if condition is true
}

Example:

let age = 20;

if (age >= 18) {
    document.write("You are eligible to vote");
}

2️⃣ if...else Statement

👉 Adds an alternative block that executes when the condition is false.

Syntax:

if (condition) {
    // Code if condition is true
} else {
    // Code if condition is false
}

Example:

let age = 16;

if (age >= 18) {
    document.write("You are eligible to vote");
} else {
    document.write("You are not eligible to vote");
}

3️⃣ if...else if...else Statement

👉 Used when there are multiple conditions to check.
It runs the first block whose condition is true.

Syntax:

if (condition1) {
    // Code if condition1 is true
} else if (condition2) {
    // Code if condition2 is true
} else {
    // Code if none of the above is true
}

Example:

let marks = 75;

if (marks >= 90) {
    document.write("Grade: A");
} else if (marks >= 75) {
    document.write("Grade: B");
} else if (marks >= 50) {
    document.write("Grade: C");
} else {
    document.write("Fail");
}

4️⃣ switch Statement

👉 An alternative to multiple if...else if.
It is used when you need to compare one value against multiple possible cases.

Syntax:

switch (expression) {
    case value1:
        // Code if expression === value1
        break;  // Stops When The Case True Otherwise It will continue.

    case value2:
        // Code if expression === value2
        break;

    default:
        // Code if no case matches
}

Example:

let day = 3;

switch (day) {
    case 1:
        document.write("Monday");
        break;
    case 2:
        document.write("Tuesday");
        break;
    case 3:
        document.write("Wednesday");
        break;
    default:
        document.write("Invalid day");
}

5️⃣ Conditional (Ternary) Operator

👉 A shorthand version of if...else.
It is written in a single line.

Syntax: 

condition ? expressionIfTrue : expressionIfFalse;

Example:

let age = 20;

let result = (age >= 18) ? "Eligible to vote" : "Not eligible to vote";

document.write(result);

⚡ Key Points to Remember

Conditions are Boolean expressions (result in true or false).

You can use comparison operators (==, ===, >, <, >=, <=, !=, !==) inside conditions.

Logical operators (&&, ||, !) can combine multiple conditions.

Nested if statements are possible (an if inside another if).

ii) Looping Statement in JavaScript:

✅ Definition

A loop in JavaScript is a control structure that allows you to execute a block of code repeatedly as long as a given condition is true.

👉 In simple words:
Instead of writing the same code multiple times, loops let you repeat tasks automatically.

🧠 Why Use Loops?

To avoid code duplication.

To iterate through arrays, objects, or strings.

To perform tasks multiple times until a condition is met.

To simplify repetitive calculations.

🔹 Types of Loops in JavaScript

JavaScript provides several types of loops:

1. for loop

2. while loop

3. do...while loop

4. for...in loop

5. for...of loop


1️⃣ for loop

Definition:
The for loop is a counter-based loop used when you know exactly how many times you want to repeat a block of code. 
It has three parts: initialization, condition, and increment/decrement.

Syntax:

for (initialization; condition; increment/decrement) {
    // code block
}

2️⃣ while loop

Definition:
The while loop is an entry-controlled loop that executes a block of code as long as the condition is true. 
The condition is checked before each iteration, so if the condition is false at the beginning, the loop will not run even once.

Syntax:

while (condition) {
    // code block
}

3️⃣ do...while loop

Definition:
The do...while loop is an exit-controlled loop that executes a block of code at least once, 
and then continues running as long as the condition is true. The condition is checked after each iteration.

Syntax:

do {
    // code block
} while (condition);

4️⃣ for...in loop

Definition:
The for...in loop is used to iterate over the enumerable properties (keys) of an object. 
It gives you the keys/indexes instead of values directly.

Syntax:

for (let key in object) {
    // use object[key]
}

5️⃣ for...of loop

Definition:
The for...of loop is used to iterate over iterable objects such as arrays, strings, maps, sets, etc. 
It gives you the values directly instead of keys or indexes.

Syntax:

for (let value of iterable) {
    // use value
}


✅ Quick Comparison Table

| Loop Type    | Control Type       | Used For                               |
| ------------ | ------------------ | -------------------------------------- |
| `for`        | Entry-controlled   | Known number of iterations (counter).  |
| `while`      | Entry-controlled   | Unknown iterations, condition first.   |
| `do...while` | Exit-controlled    | Executes at least once.                |
| `for...in`   | Object iteration   | Iterating over **keys/properties**.    |
| `for...of`   | Iterable iteration | Iterating over **values** of iterable. |


iii) Loops Control Statement:

✅ Definition

Loop control statements are special keywords in JavaScript that change the normal flow of loops.
They allow us to:

1. Stop a loop early (break)

2. Skip a particular iteration (continue)

3. Jump to specific labels (label with break/continue – rarely used)


1️⃣ break Statement

Definition:
The break statement is used to immediately exit a loop, regardless of the condition.
Once break is encountered, the loop stops completely and control moves to the next statement after the loop.

Syntax:

for (let i = 1; i <= 10; i++) {
    if (i === 5) {
        break;  // Exit loop when i = 5
    }
    document.write(i + "<br>");
}
Output:
1
2
3
4

👉 The loop stops when i becomes 5.

2️⃣ continue Statement

Definition:
The continue statement is used to skip the current iteration of the loop and move to the next iteration.
Unlike break, it does not exit the loop completely.

Syntax:

for (let i = 1; i <= 5; i++) {
    if (i === 3) {
        continue;  // Skip iteration when i = 3
    }
    document.write(i + "<br>");
}
Output:
1
2
4
5

👉 The loop runs for all values except 3 (skipped).

3️⃣ Labels with break and continue

Definition:
JavaScript allows you to put a label before a loop and then use break or continue with that label.
This is useful for nested loops, when you want to control an outer loop from inside an inner loop.

Syntax:

outerLoop: for (let i = 1; i <= 3; i++) {
    for (let j = 1; j <= 3; j++) {
        if (i === 2 && j === 2) {
            break outerLoop; // Break outer loop directly
        }
        document.write("i=" + i + ", j=" + j + "<br>");
    }
}
Output:
i=1, j=1
i=1, j=2
i=1, j=3
i=2, j=1

👉 When i=2 and j=2, it breaks the outer loop (not just the inner loop).

Similarly, you can use continue outerLoop; to skip to the next iteration of the outer loop.

8) Type Conversion In JavaScript:

In JavaScript, values can be converted from one data type to another. This is called Type Conversion.

There are two types of type conversion:

i)Type Casting (Explicit Conversion) → Done manually by the programmer.

ii)Type Coercion (Implicit Conversion) → Done automatically by JavaScript.


i)Type Casting (Explicit Conversion):

👉 When you manually convert a value from one type to another using JavaScript functions.
Done manually by the programmer.

🔹 1. String Conversion
Definition:

String conversion means explicitly converting any value into a string data type.
We use:

👉 String(value) → safest, works with everything.

👉 value.toString() → works for numbers, booleans, arrays, objects — but not for null and undefined (throws error).

Example:

// Using String()
String(123);        // "123"
String(true);       // "true"
String(null);       // "null"
String(undefined);  // "undefined"
String([1, 2, 3]);  // "1,2,3"
String({a: 1});     // "[object Object]"

// Using toString()
(123).toString();   // "123"
true.toString();    // "true"
[1, 2, 3].toString(); // "1,2,3"

// ❌ Error cases
// null.toString();   // ❌ TypeError
// undefined.toString(); // ❌ TypeError


.

🔹 2. Number Conversion
Definition:

Number conversion means explicitly converting a value into a numeric data type.
We use:

👉Number(value) → converts to number, returns NaN if not valid.

👉 parseInt(value, radix) → parses a string as an integer.

👉 parseFloat(value) → parses a string as a floating-point number.

👉 Unary +value → shortcut for Number(value).

Example:

// Using Number()
Number("123");      // 123
Number("  123 ");   // 123  (ignores spaces)
Number("123abc");   // NaN  (invalid number)
Number(true);       // 1
Number(false);      // 0
Number(null);       // 0
Number(undefined);  // NaN

// Using parseInt()
parseInt("123");      // 123
parseInt("123.45");   // 123   (only integer part)
parseInt("123abc");   // 123   (stops at non-numeric)
parseInt("abc123");   // NaN   (starts with non-numeric)
parseInt("08", 10);   // 8     (always pass radix 10)

// Using parseFloat()
parseFloat("123.45");  // 123.45
parseFloat("123abc");  // 123   (stops at non-numeric)
parseFloat("abc123");  // NaN

// Using Unary Plus
+"123";    // 123
+true;     // 1
+false;    // 0
+"123abc"; // NaN


🔹 3. Boolean Conversion
Definition:

Boolean conversion means explicitly converting a value into either true or false.
We use:

👉 Boolean(value) → Converts values into true/false.

👉 Or use double NOT operator !!value (shortcut).

👉 alsy Values (become false):

false

0, -0

0n (BigInt zero)

"" (empty string)

null

undefined

NaN

Everything else is truthy (becomes true).

Example:

Boolean(1);         // true
Boolean(0);         // false
Boolean("");        // false
Boolean("hello");   // true
Boolean(null);      // false
Boolean(undefined); // false
Boolean(NaN);       // false
Boolean([]);        // true  (empty array is truthy)
Boolean({});        // true  (empty object is truthy)

// Using !! (shortcut)
!!"hello";  // true
!!0;        // false
